<!DOCTYPE HTML>
<html lang="en">
	<head>
		<title>180旗帜</title>
		<meta charset="utf-8">
		<style type="text/css">
			body {
				background: #000;
				color: #999;
				padding: 0;
				margin: 0;
				overflow: hidden;
				font-family: georgia;
				font-size:1em;
				text-align: center;
			}

			#stats { position: absolute; top:0; left: 0 }
		</style>
	</head>

	<body>
		<div id="container"></div>

		<script src="build/three.min.js"></script>

		<script src="js/controls/OrbitControls.js"></script>
		<script src="js/controls/DeviceOrientationControls.js"></script>

		<script src="js/shaders/BleachBypassShader.js"></script>
		<script src="js/shaders/ConvolutionShader.js"></script>
		<script src="js/shaders/CopyShader.js"></script>
		<script src="js/shaders/HorizontalTiltShiftShader.js"></script>
		<script src="js/shaders/LuminosityShader.js"></script>
		<script src="js/shaders/NormalMapShader.js"></script>
		<script src="js/shaders/VerticalTiltShiftShader.js"></script>

		<script src="js/postprocessing/EffectComposer.js"></script>
		<script src="js/postprocessing/RenderPass.js"></script>
		<script src="js/postprocessing/BloomPass.js"></script>
		<script src="js/postprocessing/ShaderPass.js"></script>
		<script src="js/postprocessing/MaskPass.js"></script>
		<script src="js/postprocessing/SavePass.js"></script>

		<script src="js/BufferGeometryUtils.js"></script>
		<script src="js/ShaderTerrain.js"></script>

		<script src="js/Detector.js"></script>
		<script src="js/libs/stats.min.js"></script>

		<script src="js/Cloth.js"></script>

		<script id="fragmentShaderNoise" type="x-shader/x-fragment">

			//
			// Description : Array and textureless GLSL 3D simplex noise function.
			//      Author : Ian McEwan, Ashima Arts.
			//  Maintainer : ijm
			//     Lastmod : 20110409 (stegu)
			//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.
			//               Distributed under the MIT License. See LICENSE file.
			//

			uniform float time;
			varying vec2 vUv;
			vec4 permute( vec4 x ) {
				return mod( ( ( x * 34.0 ) + 1.0 ) * x, 289.0 );
			}

			vec4 taylorInvSqrt( vec4 r ) {
				return 1.79284291400159 - 0.85373472095314 * r;
			}

			float snoise( vec3 v ) {
				const vec2 C = vec2( 1.0 / 6.0, 1.0 / 3.0 );
				const vec4 D = vec4( 0.0, 0.5, 1.0, 2.0 );
				// First corner
				vec3 i  = floor( v + dot( v, C.yyy ) );
				vec3 x0 = v - i + dot( i, C.xxx );
				// Other corners
				vec3 g = step( x0.yzx, x0.xyz );
				vec3 l = 1.0 - g;
				vec3 i1 = min( g.xyz, l.zxy );
				vec3 i2 = max( g.xyz, l.zxy );
				vec3 x1 = x0 - i1 + 1.0 * C.xxx;
				vec3 x2 = x0 - i2 + 2.0 * C.xxx;
				vec3 x3 = x0 - 1. + 3.0 * C.xxx;
				// Permutations
				i = mod( i, 289.0 );
				vec4 p = permute( permute( permute(
						 i.z + vec4( 0.0, i1.z, i2.z, 1.0 ) )
					   + i.y + vec4( 0.0, i1.y, i2.y, 1.0 ) )
					   + i.x + vec4( 0.0, i1.x, i2.x, 1.0 ) );
				// Gradients
				//( N*N points uniformly over a square, mapped onto an octahedron.)
				float n_ = 1.0 / 7.0; // N=7
				vec3 ns = n_ * D.wyz - D.xzx;
				vec4 j = p - 49.0 * floor( p * ns.z *ns.z );  //  mod(p,N*N)
				vec4 x_ = floor( j * ns.z );
				vec4 y_ = floor( j - 7.0 * x_ );    // mod(j,N)
				vec4 x = x_ *ns.x + ns.yyyy;
				vec4 y = y_ *ns.x + ns.yyyy;
				vec4 h = 1.0 - abs( x ) - abs( y );
				vec4 b0 = vec4( x.xy, y.xy );
				vec4 b1 = vec4( x.zw, y.zw );
				vec4 s0 = floor( b0 ) * 2.0 + 1.0;
				vec4 s1 = floor( b1 ) * 2.0 + 1.0;
				vec4 sh = -step( h, vec4( 0.0 ) );
				vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;
				vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;
				vec3 p0 = vec3( a0.xy, h.x );
				vec3 p1 = vec3( a0.zw, h.y );
				vec3 p2 = vec3( a1.xy, h.z );
				vec3 p3 = vec3( a1.zw, h.w );
				// Normalise gradients
				vec4 norm = taylorInvSqrt( vec4( dot( p0, p0 ), dot( p1, p1 ), dot( p2, p2 ), dot( p3, p3 ) ) );
				p0 *= norm.x;
				p1 *= norm.y;
				p2 *= norm.z;
				p3 *= norm.w;
				// Mix final noise value
				vec4 m = max( 0.6 - vec4( dot( x0, x0 ), dot( x1, x1 ), dot( x2, x2 ), dot( x3, x3 ) ), 0.0 );
				m = m * m;
				return 42.0 * dot( m*m, vec4( dot( p0, x0 ), dot( p1, x1 ),
											  dot( p2, x2 ), dot( p3, x3 ) ) );
			}

			float surface3( vec3 coord ) {
				float n = 0.0;
				n += 1.0 * abs( snoise( coord ) );
				n += 0.5 * abs( snoise( coord * 2.0 ) );
				n += 0.25 * abs( snoise( coord * 4.0 ) );
				n += 0.125 * abs( snoise( coord * 8.0 ) );
				return n;
			}
			void main( void ) {
				vec3 coord = vec3( vUv, -time );
				float n = surface3( coord );
				gl_FragColor = vec4( vec3( n, n, n ), 1.0 );

			}
		</script>

		<script id="vertexShader" type="x-shader/x-vertex">
			varying vec2 vUv;
			uniform vec2 scale;
			uniform vec2 offset;
			void main( void ) {
				vUv = uv * scale + offset;
				gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
			}
		</script>



		<script type="x-shader/x-fragment" id="fragmentShaderDepth">
			uniform sampler2D texture;
			varying vec2 vUV;
			vec4 pack_depth( const in float depth ) {
				const vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );
				const vec4 bit_mask  = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );
				vec4 res = fract( depth * bit_shift );
				res -= res.xxyz * bit_mask;
				return res;
			}
			void main() {
				vec4 pixel = texture2D( texture, vUV );
				if ( pixel.a < 0.5 ) discard;
				gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );
			}
		</script>

		<script type="x-shader/x-vertex" id="vertexShaderDepth">
			varying vec2 vUV;
			void main() {
				vUV = 0.75 * uv;
				vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
				gl_Position = projectionMatrix * mvPosition;
			}
		</script>




		<script>
		    document.addEventListener('touchmove', function(event){event.preventDefault();}, false);

			if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

			var SCREEN_WIDTH = window.innerWidth;
			var SCREEN_HEIGHT = window.innerHeight;

			var renderer, container, stats;
			var camera, scene;
			var cameraOrtho, sceneRenderTarget;

			var uniformsNoise, uniformsNormal,
				heightMap, normalMap,
				quadTarget;

			var directionalLight, pointLight;

			var terrain;

			var textureCounter = 0;

			var animDelta = 0, animDeltaDir = -1;
			var lightVal = 0, lightDir = 1;

			var clock = new THREE.Clock();

			var morph, morphs = [];

			var updateNoise = true;

			var animateTerrain = false;

			var textMesh1;

			var mlib = {};


			var diffuseTexture1, diffuseTexture2, diffuseTexture3;



			init();
			animate();

			function init() {

				container = document.getElementById( 'container' );

				// SCENE (RENDER TARGET)

				sceneRenderTarget = new THREE.Scene();

				cameraOrtho = new THREE.OrthographicCamera( SCREEN_WIDTH / - 2, SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2, SCREEN_HEIGHT / - 2, -10000, 10000 );
				cameraOrtho.position.z = 100;

				sceneRenderTarget.add( cameraOrtho );

				// CAMERA
				camera = new THREE.PerspectiveCamera( 40, SCREEN_WIDTH / SCREEN_HEIGHT, 2, 40000 );
				camera.position.set( 0, 1200, 1000 );


				//CONTROL
				controls = new THREE.OrbitControls( camera );
				controls.target.set( 0, 500, 0 );
				controls.rotateSpeed = 1.0;
				controls.zoomSpeed = 1.2;
				controls.panSpeed = 0.8;
				controls.keys = [ 65, 83, 68 ];


				
				// controls = new THREE.DeviceOrientationControls( camera );
			 //    controls.connect();
			 //    camera.position.set( 0, 1200, 0 );
			    


				// SCENE (FINAL)
				scene = new THREE.Scene();
				scene.fog = new THREE.Fog( 0x050505, 2000, 4000 );



				// LIGHTS
				scene.add( new THREE.AmbientLight( 0x111111 ) );

				directionalLight = new THREE.DirectionalLight( 0xffffff, 1.15 );
				directionalLight.position.set( 500, 2000, 0 );
				scene.add( directionalLight );

				pointLight = new THREE.PointLight( 0xff44ff, 1.5 );
				pointLight.position.set( 0, 0, 0 );
				scene.add( pointLight );


				// HEIGHT + NORMAL MAPS

				var normalShader = THREE.NormalMapShader;

				var rx = 256, ry = 256;
				var pars = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBFormat };

				heightMap  = new THREE.WebGLRenderTarget( rx, ry, pars );
				heightMap.generateMipmaps = false;

				normalMap = new THREE.WebGLRenderTarget( rx, ry, pars );
				normalMap.generateMipmaps = false;

				uniformsNoise = {
					time:   { type: "f", value: 1.0 },
					scale:  { type: "v2", value: new THREE.Vector2( 1.5, 1.5 ) },
					offset: { type: "v2", value: new THREE.Vector2( 0, 0 ) }
				};

				uniformsNormal = THREE.UniformsUtils.clone( normalShader.uniforms );
				uniformsNormal.height.value = 0.05;
				uniformsNormal.resolution.value.set( rx, ry );
				uniformsNormal.heightMap.value = heightMap;

				var vertexShader = document.getElementById( 'vertexShader' ).textContent;

				// TEXTURES
				var specularMap = new THREE.WebGLRenderTarget( 2048, 2048, pars );
				specularMap.generateMipmaps = false;

				diffuseTexture1 = THREE.ImageUtils.loadTexture( "textures/s/grasslight-big.jpg", null, function () {
					loadTextures();
					applyShader( THREE.LuminosityShader, diffuseTexture1, specularMap );

				} );

				diffuseTexture2 = THREE.ImageUtils.loadTexture( "textures/s/t2.jpg", null, loadTextures );
				diffuseTexture3 = THREE.ImageUtils.loadTexture( "textures/s/t3.jpg", null, loadTextures );
				diffuseTexture4 = THREE.ImageUtils.loadTexture( "textures/s/t4.jpg", null, loadTextures );
				diffuseTexture5 = THREE.ImageUtils.loadTexture( "textures/s/t5.jpg", null, loadTextures );

				var detailTexture = THREE.ImageUtils.loadTexture( "textures/s/grasslight-big-nm.jpg", null, loadTextures );

				diffuseTexture1.wrapS = diffuseTexture1.wrapT = THREE.RepeatWrapping;


				diffuseTexture2.wrapS = diffuseTexture2.wrapT = THREE.RepeatWrapping;
				diffuseTexture3.wrapS = diffuseTexture3.wrapT = THREE.RepeatWrapping;
				diffuseTexture4.wrapS = diffuseTexture4.wrapT = THREE.RepeatWrapping;
				diffuseTexture5.wrapS = diffuseTexture5.wrapT = THREE.RepeatWrapping;
				

				detailTexture.wrapS = detailTexture.wrapT = THREE.RepeatWrapping;
				specularMap.wrapS = specularMap.wrapT = THREE.RepeatWrapping;

				// TERRAIN SHADER

				var terrainShader = THREE.ShaderTerrain[ "terrain" ];

				uniformsTerrain = THREE.UniformsUtils.clone( terrainShader.uniforms );

				uniformsTerrain[ "tNormal" ].value = normalMap;
				uniformsTerrain[ "uNormalScale" ].value = 3.5;

				uniformsTerrain[ "tDisplacement" ].value = heightMap;

				uniformsTerrain[ "tDiffuse1" ].value = diffuseTexture1;
				uniformsTerrain[ "tDiffuse2" ].value = diffuseTexture2;
				uniformsTerrain[ "tSpecular" ].value = specularMap;
				uniformsTerrain[ "tDetail" ].value = detailTexture;

				uniformsTerrain[ "enableDiffuse1" ].value = true;
				uniformsTerrain[ "enableDiffuse2" ].value = true;
				uniformsTerrain[ "enableSpecular" ].value = true;

				uniformsTerrain[ "diffuse" ].value.setHex( 0xffffff );
				uniformsTerrain[ "specular" ].value.setHex( 0xffffff );

				uniformsTerrain[ "shininess" ].value = 30;

				uniformsTerrain[ "uDisplacementScale" ].value = 300;//hill height

				uniformsTerrain[ "uRepeatOverlay" ].value.set( 6, 6 );



				var params = [
					[ 'heightmap', 	document.getElementById( 'fragmentShaderNoise' ).textContent, 	vertexShader, uniformsNoise, false ],
					[ 'normal', 	normalShader.fragmentShader,  normalShader.vertexShader, uniformsNormal, false ],
					[ 'terrain', 	terrainShader.fragmentShader, terrainShader.vertexShader, uniformsTerrain, true ]
				 ];

				for( var i = 0; i < params.length; i ++ ) {

					material = new THREE.ShaderMaterial( {
						uniforms: 		params[ i ][ 3 ],
						vertexShader: 	params[ i ][ 2 ],
						fragmentShader: params[ i ][ 1 ],
						lights: 		params[ i ][ 4 ],
						fog: 			true
						} );

					mlib[ params[ i ][ 0 ] ] = material;

				}


				var plane = new THREE.PlaneBufferGeometry( SCREEN_WIDTH, SCREEN_HEIGHT );
				quadTarget = new THREE.Mesh( plane, new THREE.MeshBasicMaterial( { color: 0x000000 } ) );
				quadTarget.position.z = -500;
				sceneRenderTarget.add( quadTarget );

				// TERRAIN MESH
				var geometryTerrain = new THREE.PlaneBufferGeometry( 5000, 5000, 256, 256 );

				THREE.BufferGeometryUtils.computeTangents( geometryTerrain );

				terrain = new THREE.Mesh( geometryTerrain, mlib[ "terrain" ] );
				terrain.position.set( 0, -400, 0 );
				terrain.rotation.x = -Math.PI / 2;
				terrain.visible = false;
				scene.add( terrain );

				// RENDERER

				renderer = new THREE.WebGLRenderer();
				// renderer.setClearColor( scene.fog.color );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( SCREEN_WIDTH, SCREEN_HEIGHT );
				container.appendChild( renderer.domElement );

				//

				renderer.gammaInput = true;
				renderer.gammaOutput = true;


				// STATS

				stats = new Stats();
				// container.appendChild( stats.domElement );

				// EVENTS

				onWindowResize();

				window.addEventListener( 'resize', onWindowResize, false );

				document.addEventListener( 'keydown', onKeyDown, false );

				// COMPOSER

				renderer.autoClear = false;

				renderTargetParameters = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBFormat, stencilBuffer: false };

				renderTarget = new THREE.WebGLRenderTarget( SCREEN_WIDTH, SCREEN_HEIGHT, renderTargetParameters );
				renderTarget.generateMipmaps = false;

				effectBloom = new THREE.BloomPass( 0.4 );
				var effectBleach = new THREE.ShaderPass( THREE.BleachBypassShader );

				hblur = new THREE.ShaderPass( THREE.HorizontalTiltShiftShader );
				vblur = new THREE.ShaderPass( THREE.VerticalTiltShiftShader );

				var bluriness = 3;

				hblur.uniforms[ 'h' ].value = bluriness / SCREEN_WIDTH;
				vblur.uniforms[ 'v' ].value = bluriness / SCREEN_HEIGHT;

				hblur.uniforms[ 'r' ].value = vblur.uniforms[ 'r' ].value = 0.5;

				effectBleach.uniforms[ 'opacity' ].value = 0.65;

				var renderModel = new THREE.RenderPass( scene, camera );

				vblur.renderToScreen = true;

				composer = new THREE.EffectComposer( renderer, renderTarget );
				composer.addPass( renderModel );
				composer.addPass( effectBloom );
				// composer.addPass( effectBleach );

				composer.addPass( hblur );
				composer.addPass( vblur );

				// MORPHS

				function addMorph( geometry, size, duration, x, y, z ) {

					var material = new THREE.MeshLambertMaterial( { color: 0xffaa55, morphTargets: true, vertexColors: THREE.FaceColors } );

					var mesh = new THREE.Mesh( geometry, material );
					// mesh.speed = speed;

					var mixer = new THREE.AnimationMixer( mesh );
					mixer.addAction( new THREE.AnimationAction( geometry.animations[0] ).warpToDuration( duration ) );
					mixer.update( 600 * Math.random() );
					mesh.mixer = mixer;

					mesh.position.set( x, y, z );
					mesh.rotation.y = Math.PI/2;

					mesh.scale.set( size, size, size );

					mesh.castShadow = true;
					mesh.receiveShadow = false;


					scene.add( mesh );

					morphs.push( mesh );

				}

				var loader = new THREE.JSONLoader();


				loader.load( "models/animated/parrot.js", function( geometry ) {
					addMorph( geometry, 0.6, 0.5, Math.random()*1000-500, 500, Math.random()*1000-500 );
					addMorph( geometry, 0.4, 0.5, Math.random()*1000-500, 500, Math.random()*1000-500 );
					addMorph( geometry, 0.5, 0.5, Math.random()*1000-500, 500, Math.random()*1000-500 );
					addMorph( geometry, 0.5, 0.5, Math.random()*1000-500, 500, Math.random()*1000-500 );

				} );

				loader.load( "models/animated/flamingo.js", function( geometry ) {
					addMorph( geometry, 1, 1, Math.random()*1000-500, 350, Math.random()*1000-500 );
					// addMorph( geometry, 1, 1, Math.random()*1000-500, 350, Math.random()*1000-500 );
				} );

				loader.load( "models/animated/stork.js", function( geometry ) {
					addMorph( geometry, 1.6, 1.5, 0, 300, 0);
				} );

				// loader.load( "models/animated/horse.js", function( geometry ) {
				// 	addMorph( geometry, 350, 1, Math.random()*1000-500, 150, 100 );
				// 	addMorph( geometry, 350, 1, Math.random()*1000-500, 150, 600 );
				// } );


				initCloth();
			}

			//

			function onWindowResize( event ) {

				SCREEN_WIDTH = window.innerWidth;
				SCREEN_HEIGHT = window.innerHeight;

				renderer.setSize( SCREEN_WIDTH, SCREEN_HEIGHT );

				camera.aspect = SCREEN_WIDTH / SCREEN_HEIGHT;
				camera.updateProjectionMatrix();

			}

			//

			function onKeyDown ( event ) {
				switch( event.keyCode ) {
					case 78: /*N*/  lightDir *= -1; break;
					case 77: /*M*/  animDeltaDir *= -1; break;
				}
			}

			//

			function applyShader( shader, texture, target ) {

				var shaderMaterial = new THREE.ShaderMaterial( {

					fragmentShader: shader.fragmentShader,
					vertexShader: shader.vertexShader,
					uniforms: THREE.UniformsUtils.clone( shader.uniforms )

				} );

				shaderMaterial.uniforms[ "tDiffuse" ].value = texture;

				var sceneTmp = new THREE.Scene();

				var meshTmp = new THREE.Mesh( new THREE.PlaneBufferGeometry( SCREEN_WIDTH, SCREEN_HEIGHT ), shaderMaterial );
				meshTmp.position.z = -500;

				sceneTmp.add( meshTmp );

				renderer.render( sceneTmp, cameraOrtho, target, true );

			}

			//

			function loadTextures() 
			{
				textureCounter += 1;
				if ( textureCounter == 5 )	{
					terrain.visible = true;
				}
			}





			// var pinsFormation = [];
			var pins = [ 0, 1, 2, 3, 4, 5, 6, 7, 8 ];

			var clothGeometry;
			var clothObject;
			function initCloth()
			{
				// cloth material
				var clothTexture = THREE.ImageUtils.loadTexture( 'textures/circuit_180.png' );
				clothTexture.wrapS = clothTexture.wrapT = THREE.RepeatWrapping;
				clothTexture.anisotropy = 6;

				var clothMaterial = new THREE.MeshPhongMaterial( {
					specular: 0x030303,
					emissive: 0x111111,
					map: clothTexture,
					side: THREE.DoubleSide,
					alphaTest: 0.5
				} );

				// cloth geometry
				clothGeometry = new THREE.ParametricGeometry( clothFunction, cloth.w, cloth.h );
				clothGeometry.dynamic = true;

				var uniforms = { texture:  { type: "t", value: clothTexture } };
				var vertexShader = document.getElementById( 'vertexShaderDepth' ).textContent;
				var fragmentShader = document.getElementById( 'fragmentShaderDepth' ).textContent;

				// cloth mesh

				clothObject = new THREE.Mesh( clothGeometry, clothMaterial );
				clothObject.position.set(2000, 300, 2000 );

				clothObject.castShadow = false;
				scene.add( clothObject );

				clothObject.customDepthMaterial = new THREE.ShaderMaterial( {
					uniforms: uniforms,
					vertexShader: vertexShader,
					fragmentShader: fragmentShader,
					side: THREE.DoubleSide
				} );
			}




            var changeAble=true;
			function changeStage()
			{
				if(!changeAble)return;

				changeAble=false;
				setTimeout(function(){
					changeAble=true;
				},3000)


				
				var _i=Math.floor(Math.random()*5+1);
				var _j=Math.floor(Math.random()*5+1);
				console.log(_i);
				console.log(_j);

				if(_i==1)uniformsTerrain[ "tDiffuse1" ].value = diffuseTexture1;
				if(_i==2)uniformsTerrain[ "tDiffuse1" ].value = diffuseTexture2;
				if(_i==3)uniformsTerrain[ "tDiffuse1" ].value = diffuseTexture3;
				if(_i==4)uniformsTerrain[ "tDiffuse1" ].value = diffuseTexture4;
				if(_i==5)uniformsTerrain[ "tDiffuse1" ].value = diffuseTexture5;

				if(_j==1)uniformsTerrain[ "tDiffuse2" ].value = diffuseTexture1;
				if(_j==2)uniformsTerrain[ "tDiffuse2" ].value = diffuseTexture2;
				if(_j==3)uniformsTerrain[ "tDiffuse2" ].value = diffuseTexture3;
				if(_j==4)uniformsTerrain[ "tDiffuse2" ].value = diffuseTexture4;
				if(_j==5)uniformsTerrain[ "tDiffuse2" ].value = diffuseTexture5;




				uniformsTerrain[ "uDisplacementScale" ].value = Math.random()*500+200;//hill height


				animDeltaDir *= -1;
				// lightDir *= -1; 
			}








			//
			function animate() {

				requestAnimationFrame( animate );


				var time = Date.now();
				windStrength = Math.cos( time / 6000 ) * 40 + 100;
				windForce.set( Math.sin( time / 2000 ), Math.cos( time / 3000 ), Math.sin( time / 1000 ) ).normalize().multiplyScalar( windStrength );

				simulate(time);


				render();
				// stats.update();
			}

			function render() {

				var delta = clock.getDelta();

				if ( terrain.visible ) {

					controls.update();

					var time = Date.now() * 0.001;

					var fLow = 0.1, fHigh = 0.8;

					lightVal = THREE.Math.clamp( lightVal + 0.5 * delta * lightDir, fLow, fHigh );

					var valNorm = ( lightVal - fLow ) / ( fHigh - fLow );

					scene.fog.color.setHSL( 0.1, 0.5, lightVal );
					renderer.setClearColor( scene.fog.color );

					directionalLight.intensity = THREE.Math.mapLinear( valNorm, 0, 1, 0.1, 1.15 );
					pointLight.intensity = THREE.Math.mapLinear( valNorm, 0, 1, 0.9, 1.5 );

					uniformsTerrain[ "uNormalScale" ].value = THREE.Math.mapLinear( valNorm, 0, 1, 0.6, 3.5 );



					var _a=camera.rotation.z+Math.PI/2;
					var _x=delta * Math.cos(_a) *0.2;
					var _y=delta * Math.sin(_a) *0.2;



					if ( updateNoise ) {

						animDelta = THREE.Math.clamp( animDelta + 0.00075 * animDeltaDir, 0, 0.05 );

						uniformsNoise[ "time" ].value += delta * animDelta;

						uniformsNoise[ "offset" ].value.x += _x;
						uniformsTerrain[ "uOffset" ].value.x = 4 * uniformsNoise[ "offset" ].value.x;

						uniformsNoise[ "offset" ].value.y += _y;
						uniformsTerrain[ "uOffset" ].value.y = 4 * uniformsNoise[ "offset" ].value.y;						
						quadTarget.material = mlib[ "heightmap" ];
						renderer.render( sceneRenderTarget, cameraOrtho, heightMap, true );

						quadTarget.material = mlib[ "normal" ];
						renderer.render( sceneRenderTarget, cameraOrtho, normalMap, true );

						// updateNoise = false;
					}




					var timer = Date.now() * 0.0002;
					var p = cloth.particles;
					for ( var i = 0, il = p.length; i < il; i ++ ) {
						clothGeometry.vertices[ i ].copy( p[ i ].position );
					}
					clothGeometry.computeFaceNormals();
					clothGeometry.computeVertexNormals();
					clothGeometry.normalsNeedUpdate = true;
					clothGeometry.verticesNeedUpdate = true;

					clothObject.position.x+= -Math.cos(_a)*10;
					clothObject.position.z+= Math.sin(_a)*10;

					if(clothObject.position.x>2000)clothObject.position.x=-2000;
					if(clothObject.position.z>2000)clothObject.position.z=-2000;

					if(clothObject.position.x<-2000)clothObject.position.x=2000;
					if(clothObject.position.z<-2000)clothObject.position.z=2000;


					if(clothObject.position.x<100 && clothObject.position.x>-100)
					{
						if(clothObject.position.z<100 && clothObject.position.z>-100)
						{
							clothObject.position.y+=50;
							lightDir = -1; 

							setTimeout(function(){
								changeStage();
								lightDir = 1; 
								
							},2000);

							setTimeout(function(){
								clothObject.position.set(2000, 300, Math.random()*4000-2000 );
								clothObject.rotation.y=Math.random()*Math.PI;

								
							},3000);


						}
					}

					clothObject.rotation.y+=0.02;



					// console.log("z_"+  camera.rotation.z/Math.PI);
					for ( var i = 0; i < morphs.length; i ++ ) {
						morph = morphs[ i ];
						morph.mixer.update( delta );

						// var v1 = new THREE.Vector3( Math.sin(_a), 0, Math.cos(_a) );
						// morph.translateOnAxis(v1,10);

						morph.rotation.y=camera.rotation.z+Math.PI;

						// morph.position.x += morph.speed * delta;
						// if ( morph.position.x  > 2000 )  {
						// 	morph.position.x = -1500 - Math.random() * 500;
						// }
					}

					// renderer.render( scene, camera );
					composer.render( 0.1 );

				}

			}

		</script>

	</body>
</html>
