<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<meta name="viewport" id="viewport" content="width=device-width, user-scalable=no, minimum-scale=1, maximum-scale=1">
		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="apple-mobile-web-app-status-bar-style" content="black">
		<title>3D180</title>
		<link type="text/css" rel="stylesheet" href="style.css" />

	</head>

	<body>
		<script src="build/three.min.js"></script>
		<script src="build/jquery-1.8.0.min.js"></script>
		<script src="build/TweenMax.min.js"></script>

		<script src="js/Detector.js"></script>
		<script src="js/libs/stats.min.js"></script>
		<script src="js/controls/OrbitControls.js"></script>

		<script src="js/shaders/CopyShader.js"></script>
		<script src="js/shaders/DigitalGlitch.js"></script>

		<script src="js/postprocessing/EffectComposer.js"></script>
		<script src="js/postprocessing/RenderPass.js"></script>
		<script src="js/postprocessing/MaskPass.js"></script>
		<script src="js/postprocessing/ShaderPass.js"></script>
		<script src="js/postprocessing/GlitchPass.js"></script>

		<script id="vertexShader" type="x-shader/x-vertex">
			precision highp float;
			uniform float sineTime;
			uniform mat4 modelViewMatrix;
			uniform mat4 projectionMatrix;
			attribute vec3 position;
			attribute vec3 offset;
			attribute vec4 color;
			attribute vec4 orientationStart;
			attribute vec4 orientationEnd;
			varying vec3 vPosition;
			varying vec4 vColor;
			void main(){
				vPosition = offset * max(abs(sineTime * 2.0 + 1.0), 0.5) + position;
				vec4 orientation = normalize(mix(orientationStart, orientationEnd, sineTime));
				vec3 vcV = cross(orientation.xyz, vPosition);
				vPosition = vcV * (2.0 * orientation.w) + (cross(orientation.xyz, vcV) * 2.0 + vPosition);
				vColor = color;
				gl_Position = projectionMatrix * modelViewMatrix * vec4( vPosition, 1.0 );
			}
		</script>

		<script id="fragmentShader" type="x-shader/x-fragment">
			precision highp float;
			uniform float time;
			varying vec3 vPosition;
			varying vec4 vColor;
			void main() {
				vec4 color = vec4(16742400);
				// color.r += sin( vPosition.x * 10.0 + time ) * 0.5;
				gl_FragColor = color;
			}
		</script>

		<script>
			if (!Detector.webgl) Detector.addGetWebGLMessage();

			var STATS_ENABLED = true;
			var container, stats;

			var camera, scene, renderer;
			var controls;

			var windowHalfX = window.innerWidth / 2;
			var windowHalfY = window.innerHeight / 2;

			var clock = new THREE.Clock();

			var Mesh1,Mesh8,Mesh0;
			var Tmesh1,Tmesh8,Tmesh0;
			var uniforms;
			var displacement, noise;
			var displacement8, noise8;
			var displacement0, noise0;

			var Mesh1v=[];
			var MoveV=[];

			init();
			animate();
			function init() {

			    container = document.createElement('div');
			    document.body.appendChild(container);

			    renderer = new THREE.WebGLRenderer({antialias: true, alpha: true});
			    renderer.setSize(window.innerWidth, window.innerHeight);
			    //renderer.setClearColor( scene.fog.color, 1 );
			    //renderer.setFaceCulling( THREE.CullFaceNone );
			    //renderer.autoClear = false;
			    container.appendChild(renderer.domElement);

			    // CAMERAS
			    camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
			    camera.position.y = 3;


			    controls = new THREE.OrbitControls(camera);
			    controls.damping = 0.2;

			    // SCENE
			    scene = new THREE.Scene();
			    // scene.fog = new THREE.FogExp2(15658734, 5E-5);

			    // lights
			    scene.add( new THREE.AmbientLight( 0x444444 ) );
			    var light1 = new THREE.DirectionalLight( 0xffffff, 1 );
			    light1.position.set( 1, 1, 1 );
			    scene.add( light1 );
			    var light2 = new THREE.DirectionalLight( 0xffffff, 1.5 );
			    light2.position.set( -1, -1, -1 );
			    scene.add( light2 );
			    var light3 = new THREE.PointLight(15953704, 1.5, 6);
				light3.position.set(0, 0, 0);
				scene.add( light3 );


			    //sky
				var skyM = new THREE.MeshPhongMaterial({
					color: 0xaaaaaa,
					emissive: 0x333333,
					side: THREE.BackSide
				});
				var sky = new THREE.Mesh(new THREE.SphereGeometry(10, 4, 4), skyM);
				scene.add(sky);

				// postprocessing
				composer = new THREE.EffectComposer( renderer );
				composer.addPass( new THREE.RenderPass( scene, camera ) );
				glitchPass = new THREE.GlitchPass();
				glitchPass.renderToScreen = true;
				composer.addPass( glitchPass );


			    // model1
			    var loader1 = new THREE.JSONLoader();
			    loader1.load("model/8.js", function (g) 
			    {
					var geometry = g;
					// var geometry = new THREE.IcosahedronGeometry( 1, 1 );
					// var material = new THREE.MeshLambertMaterial( { color: 0xffffff, morphTargets: true } );
					var material = new THREE.MeshPhongMaterial({
						color: 16742400,
						specular: 657930,
						shininess: 20,
						vertexColors: THREE.FaceColors,
						wireframe: !1,
						shading: THREE.FlatShading
					});

					for ( var i = 0; i < geometry.vertices.length; i ++ ) {
						Mesh1v.push( geometry.vertices[i].clone() );
						MoveV.push( geometry.vertices[i].clone() );
					}

					Mesh1 = new THREE.Mesh( geometry, material );

					Mesh1.radius =rand(50, 80);
					Mesh1.noise = rand(-20, 20);
					Mesh1.speed = .1 * rand(1, 7);
					for (var g = 0; g < Mesh1.geometry.vertices.length; g++) {
						var k = Mesh1.geometry.vertices[g];
						k.ox = k.tx = k.fx = k.x;
						k.oy = k.ty = k.fy = k.y;
						k.oz = k.tz = k.fz = k.z;
						k.range = rand(2, 8);
						k.speed = .05 * rand(1, 20);
						k.x = 0;
						k.y = 0;
						k.z = 0;
					}
					

					// for (i = 0; i < MoveV.length; i ++ ) {
					// 	MoveV[i].x = rand(-1, 1);
					// 	MoveV[i].y = rand(-1, 1);
					// 	MoveV[i].z = rand(-1, 1);
					// }
					

					setTimeout(move2,2000);

					Mesh1.position.set(0, -0.5, 0);
					scene.add( Mesh1 );


					displacement = new Float32Array(geometry.vertices.length);
					noise = new Float32Array(displacement.length );
			        for ( var i = 0; i < displacement.length; i ++ ) {
			            noise[ i ] = Math.random();
			        }
			    });



			    if (STATS_ENABLED) {

			        stats = new Stats();
			        stats.domElement.style.position = 'absolute';
			        stats.domElement.style.top = '0px';
			        stats.domElement.style.zIndex = 100;
			        container.appendChild(stats.domElement);
			    }

			    window.addEventListener('resize', onWindowResize, false);
			}

			function move2()
			{
				console.log("move2");
				for (i = 0; i < MoveV.length; i ++ ) {
					var r=rand(-10, 10);
					MoveV[i].x *= r;
					MoveV[i].y *= r;
					MoveV[i].z *= r;
				}

				setTimeout(move3,2000);
			}
			function move3()
			{
				console.log("move3");
				for (i = 0; i < MoveV.length; i ++ ) {
					MoveV[i]=Mesh1v[i].clone();
				}

				setTimeout(move2,2000);
			}



			function onWindowResize() {

			    windowHalfX = window.innerWidth / 2;
			    windowHalfY = window.innerHeight / 2;

			    camera.aspect = window.innerWidth / window.innerHeight;
			    camera.updateProjectionMatrix();

			    renderer.setSize(window.innerWidth, window.innerHeight);
			}
			//

			function animate() {
			    requestAnimationFrame(animate);

			    render();
			}

			function render() {
			    var time = Date.now() * 0.006;
			    if(Mesh1)
			    {
			        for ( var i = 0; i < Mesh1.geometry.vertices.length; i ++ ) 
			        {
						var t=Math.sin(i*0.1+time)*0.01;
						Mesh1.geometry.vertices[i].x+=((MoveV[i].x+t)-Mesh1.geometry.vertices[i].x)*0.16;
						Mesh1.geometry.vertices[i].y+=((MoveV[i].y+t)-Mesh1.geometry.vertices[i].y)*0.16;
						Mesh1.geometry.vertices[i].z+=((MoveV[i].z+t)-Mesh1.geometry.vertices[i].z)*0.16;

						Mesh1.geometry.verticesNeedUpdate = true;
			        }
		    	}


			    controls.update();
			    composer.render();
			    // renderer.render(scene, camera);


			    if (STATS_ENABLED) stats.update();
			}

			function rand(a, b, d) {
				d = 0 == d ? !1 : !0;
				a = Math.min(a + Math.random() * (b + 2 - a), b);
				return d ? parseInt(a) : a
			}


function initTriangles(vertices) {
    var triangles = vertices.length;
    var geometry = new THREE.BufferGeometry();
    var positions = new Float32Array(triangles * 3 * 3);
    var normals = new Float32Array(triangles * 3 * 3);
    var colors = new Float32Array(triangles * 3 * 3);
    var color = new THREE.Color();

    var n = 1,
        n2 = n / 2; // triangles spread in the cube
    var d = .2,
        d2 = d / 2; // individual triangle size

    var pA = new THREE.Vector3();
    var pB = new THREE.Vector3();
    var pC = new THREE.Vector3();

    var cb = new THREE.Vector3();
    var ab = new THREE.Vector3();


    for (var i = 0; i < positions.length; i += 9) {
        // positions
        var x, y, z;

        if (Math.floor(i / 9) < vertices.length) {
            // console.log(Math.floor(i/9));
            x = vertices[Math.floor(i / 9)].x;
            y = vertices[Math.floor(i / 9)].y;
            z = vertices[Math.floor(i / 9)].z;
        }

        var ax = x + Math.random() * d - d2;
        var ay = y + Math.random() * d - d2;
        var az = z + Math.random() * d - d2;

        var bx = x + Math.random() * d - d2;
        var by = y + Math.random() * d - d2;
        var bz = z + Math.random() * d - d2;

        var cx = x + Math.random() * d - d2;
        var cy = y + Math.random() * d - d2;
        var cz = z + Math.random() * d - d2;

        positions[i] = ax;
        positions[i + 1] = ay;
        positions[i + 2] = az;

        positions[i + 3] = bx;
        positions[i + 4] = by;
        positions[i + 5] = bz;

        positions[i + 6] = cx;
        positions[i + 7] = cy;
        positions[i + 8] = cz;

        // flat face normals
        pA.set(ax, ay, az);
        pB.set(bx, by, bz);
        pC.set(cx, cy, cz);

        cb.subVectors(pC, pB);
        ab.subVectors(pA, pB);
        cb.cross(ab);

        cb.normalize();

        var nx = cb.x;
        var ny = cb.y;
        var nz = cb.z;

        normals[i] = nx;
        normals[i + 1] = ny;
        normals[i + 2] = nz;

        normals[i + 3] = nx;
        normals[i + 4] = ny;
        normals[i + 5] = nz;

        normals[i + 6] = nx;
        normals[i + 7] = ny;
        normals[i + 8] = nz;

        // colors

        var vx = (x / n) + 0.5;
        var vy = (y / n) - 1;
        var vz = (z / n) + 0.5;

        color.setRGB(vx, vy, vz);

        colors[i] = color.r;
        colors[i + 1] = color.g;
        colors[i + 2] = color.b;

        colors[i + 3] = color.r;
        colors[i + 4] = color.g;
        colors[i + 5] = color.b;

        colors[i + 6] = color.r;
        colors[i + 7] = color.g;
        colors[i + 8] = color.b;
    }

    geometry.addAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.addAttribute('normal', new THREE.BufferAttribute(normals, 3));
    geometry.addAttribute('color', new THREE.BufferAttribute(colors, 3));

    geometry.computeBoundingSphere();
    return geometry;
}
	    </script>

	</body>
</html>
